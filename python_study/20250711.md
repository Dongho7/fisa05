# Pandas
---
#### 오늘은 판다스에 대해서 학습했습니다. .. . .
인덱스 변경
```python
df.index= ["신짱구", "신짱아", "훈이"]
df.index
#이와 같이 인덱스 변경 가능
```

열 삭제
```python
del df["거주지"] #열 삭제 방법 1
df.drop("거주지", axis=1, inplace = True) #inplace = True 는 바로 데이터프레임에 반영
```

Merge
```python
#자료를 변수에 할당하기
data0 = {'Name' : ['S1', 'S2', 'S3'],
         'Age' : [25, 28, 22],
         'Score' : [95, 85, 75]} # 출석부

data1 = {'Sex' : ['Male', 'Female', 'Male'],
         'Age' : [25, 28, 22],
         'Score' : [95, 85, 75]} # 학생 기본 정보

df = pd.DataFrame(data0)
df2 = pd.DataFrame(data1)

df2.merge(df) #

Sex	Age	Score	Name
0	Male	25	95	S1
1	Female	28	85	S2
2	Male	22	75	S3
```

### loc는 라벨로 접근하고, iloc는 인덱스로 접근한다.
```python
#행 추가 방법
df2.loc['가'] = ('S4', 30, 86)
df2


df_jjang.loc[df_jjang.Age > 22, "Name"]

```

## sort
```python
df.sort_values("Age", ascending=False, inplace=True, ignore_index=True) #inplace = True (기본값 False) 원본이 변경됨
#연산결과대로 다시 인덱스에 순서를 ....

df.sort_values(['Age', 'Score']) #에이지가 같으면 스코어
```

## Replace
```python
df2.Sex.replace(['Male', "Female"], ["M", "F"])

df_jjang["Result"] = df_jjang.Score>= 80
df_jjang.Result.replace([True, False], ["Pass", "Fail"], inplace=True)

df_jjang
```

## Unique
```python
df_jjang.Class.unique()
df_jjang["Class"].unique()
```

## duplicated()
```python
df_jjang[~df_jjang.Class.duplicated()]
# df_jjang[~df_jjang.Class.duplicated(), "Name"] 에러
df_jjang.loc[~df_jjang.Class.duplicated(), ["Name", "Age","Score" ]]

```

## apply
```python
df_jjang["Result"] = df_jjang["Score"].apply(
    lambda x: "Pass" if x >= 80 else "Fail"
)

df_jjang

df_jjang['Result'] = np.where(df_jjang.Score >= 80, 'Pass', 'Fail')
df_jjang


# apply(함수) 를 만드셔서 현재 '반' 컬럼의 각 원소를 확인 후 
# 원소의 결과에 따라 분점 컬럼에 다른 값을 return 시켜보세요.

df["분점"] = df.반.apply(lambda x: "광명시" if x=="장미" else "개나리" if x=="강동구" else "강서구")


#######

def function(x):
    if x == '개나리':
        return '강동구'
    elif x == '장미':
        return '광명시'
    return None

jjangu_list['반'].apply(function)


```

## astype 
```python
df= df.astype({"등록일자": "datetime64[ns]"})
```

## value_count
```python
df.등록일자.value_counts()
```

## groupby 
```python
# df.groupby("묶음의 기준이 되는 컬럼명")[적용받는 컬럼].적용받는 연산
df
df.groupby("반")["테스트점수"].count()
df.groupby("반")["테스트점수"].mean()


df.groupby("반")[["이름","테스트점수"]].sum() #자료형이 달라도 ...되기는 해..
#개나리	짱아짱구아빠짱구엄마	218
# 장미	짱구철수맹구유리훈이	383
# 그러나 mean은 안 되겠지.

df.groupby(["반", "이름"])[["테스트점수"]].mean() #이런 식으로 나눠서 쓸 수 도 있다. ~

#########################

# .sort_values(by=['store', 'price'], ascending=[True, False])
             # by=[1차기준, 2차기준], ascending=[1차기준, 2차기준]
df11.groupby(['store', 'product'])[['price', 'quantity']].
				sum().sort_values(by=['store','price'], ascending=[True,False])
```

## reset_index 

```python
df2.reset_index()
```

## datetime 
```python
#시간을 사용하기 위한 python 모듀린 datetime과 호환되는 ...
from datetime import datetime, timedelta
datetime.now() + timedelta(10)
datetime(2023, 12, 9) + timedelta(600)

value = '2022-10-7'
stamp = datetime.strptime(value, '%Y-%m-%d')
print(stamp)

df.등록일자 + timedelta(weeks=52)
```

## fillna 
```python
df.fillna(0)
```

## melt 
```python
import pandas as pd

df11=pd.DataFrame({'store':['Costco','Costco','Costco','Lotte Mart','Lotte Mart','Lotte Mart',"E-mart","E-mart","E-mart"],
               'product':['Potato','Onion','Cucumber','Potato','Onion','Cucumber','Potato','Onion','Cucumber'],
               'price':[3000,1600,2600,3200,1200,2100,2000,2300,3000],
                'quantity':[25,31,57,32,36,21,46,25,9]})
df11
df11_ = df11.melt(id_vars=['store', 'product'])
```


## stack

```python
df11

df11_pivot = df11.pivot_table(index='store', columns='product')

df11.pivot(index='store', columns='product').stack()
```


## filter 
```python

df.filter(items=["이름", "테스트점수"])

df.filter(regex = '이+') #정규표현식 사용 가능 filter 에서 ...

df.filter(like = '점') #테스트점수,분점
```

## str method 이용 

```python
#전체일치
df[df.이름.isin(["짱구", "짱아"])]

#일부일치의 경우
df.이름.str.contains("짱")
df.이름.str.startswith("짱")
df.이름.str.endsswith("짱")
```

## sort_values

```python
df.Name.sort_values()
df.sort_values("Age", ascending=False, inplace=True, ignore_index=True) #inplace = True (기본값 False) 원본이 변경됨

#연산결과대로 다시 인덱스에 순서를 ....

df.sort_values(['Age', 'Score']) #에이지가 같으면 스코어
```


## idmax()
```python

gapminder.loc[gapminder['pop'].idxmax()]
```

