# 리스트 컴프리헨션

### 오늘은 리스트 컴프리헨션에 대해서 배웠다... 
```python
li1 = [1, 2, 3, 4, 5]
li2 = [10, 20, 30, 40, 50, 60]
list(map(lambda x, y:x+y, li1, li2)) # map 등 함수형 문법을 차용한 함수를 사용할 때 주의점.
#여러 개의 집합자료형을 얹어서 사용한다면 가장 len()이 짧은 자료형을 기준으로 작동한다.
```

```python
good = {i:j for i, j in scores.items() if j >= 80}
good
#이런 식으로 딕셔너리 역시 컴프리헨션이 사용 가능하다. 
```
딕셔너리 역시 리스트컴프리헨션이 가능하다는 점, 기억하기.


```python
li = [1, 2, 3, 4, 7]
[*filter(lambda x : x%2==0, li)] # [2, 4]
# [*map(lambda x : x%2==0, li)]

#데이터 손실 가능성. len확인해보자 .

li1 = [1, 2, 3, 4, 5]
li2 = [10, 20, 30, 40, 50, 60]
list(map(lambda x, y:x+y, li1, li2)) # map 등 함수형 문법을 차용한 함수를 사용할 때 주의점.
#여러 개의 집합자료형을 얹어서 사용한다면 가장 len()이 짧은 자료형을 기준으로 작동한다.###

```
map함수를 잘 써보자.


```python
alist = ['사과', '바나나', '딸기', '오렌지'] # 4개
blist = ['Apple', 'Banana', 'Strawberry'] # 3개
clist = [100, 200, 300, 400, 500] # 5개
[*zip(alist, blist, clist)] #이것 역시 짧은 것.
```
zip과 enumerate 함수에 대해서 알아보았다.


```python
subjects = ['math', 'history', 'english', 'computer engineering']
scores = [90, 80, 95, 100]

{subject:score for subject, score in zip(subjects, scores)}
dict([*zip(subjects, scores)])

# {'math': 90, 'history': 80, 'english': 95, 'computer engineering': 100}
```

### Reduce 
```python
#0~10까지 모두 더한 값
list1 = list(range(0,11))
reduce(lambda x,y : x+y, list1)

reduce(lambda x,y : x+y, range(11))
##reduece
```

```python
test2 = [{'name' : 'a', 'age' : 1}, {'name' : 'b', 'age' : 2}, {'name' : 'c', 'age' : 3}]
reduce(lambda x, y: x + y['age'], test2, 0) / len(test2)

# 얘가 X가 되고, {'name' : 'a', 'age' : 1}
# 얘가 Y가 된다  {'name' : 'b', 'age' : 2)
#뎁스를 타고 들어갈 때, 초기의 결과값...이 뭔지....
```
 reduce가 어떤 식으로 작동하는지.. 이해해보자. 
----
# 문자열 메소드
**Split**
```python

str1 = '안녕/안녕/안녕하세요/반가워요/좋은아침입니다'
str1.split("/")
str1.split("/", 2) #['안녕', '안녕', '안녕하세요', '반가워요', '좋은아침입니다']
```
**replace**
```python
str1 = '안녕 나는 짱구 아빠야'
str1.replace("안녕", "짱구")
```
**strip**
```python
actors = '1010로미오&줄리엣1010'
actors.strip("1010")
```
**join**
```python
a = ['짱구', '짱아', '장구엄마', '짱구아빠']

"*".join(a) #split과 반대
#짱구*짱아*장구엄마*짱구아빠
```

---
문자열 정리 
```python
string.count("happy")+string.count("Happy")
string.lower().count("happy") #이게 맞음
```

```python
words = set(map(str.lower, string.split(' '))) #lower와 set으로 고유 단어 리스트를 확인
```

**Counter**
```python
from collections import Counter

# 예시 1: 문자열에서 문자 빈도 세기
c1 = Counter("banana")
print(c1)  # 출력: Counter({'a': 3, 'n': 2, 'b': 1})
c1.most_common(3) #가장 많이 나온 영단어
# 예시 2: 리스트에서 단어 빈도 세기
words = ['apple', 'banana', 'apple', 'orange', 'banana', 'banana']
c2 = Counter(words)
print(c2)  # 출력: Counter({'banana': 3, 'apple': 2, 'orange': 1})
```

**find**
- 문자열에 포함된 첫번째 요소의 index 값 반환
- 찾고자 하는 특정 문자열이 여러 개인 경우에는 최초 발견한 원소의 시작위치만 알려준다. (여러개 찾을 때는 re 모듈의 finditer 활용)

```python
str1 = 'IT AI AI Engineering Engineer deer'
str1.find("ai") #0
str1.find("AI") #3
```
---
#Re 패키지 활용 
**search**
```python
import re

text = "My phone number is 010-1234-5678"
match = re.search(r"\d{3}-\d{4}-\d{4}", text)
print(match.group())  # 010-1234-5678
```

```python

```
