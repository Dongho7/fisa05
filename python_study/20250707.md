# 리스트 컴프리헨션

오늘은 리스트 컴프리헨션에 대해서 배웠다. 
```python
li1 = [1, 2, 3, 4, 5]
li2 = [10, 20, 30, 40, 50, 60]
list(map(lambda x, y:x+y, li1, li2)) # map 등 함수형 문법을 차용한 함수를 사용할 때 주의점.
#여러 개의 집합자료형을 얹어서 사용한다면 가장 len()이 짧은 자료형을 기준으로 작동한다.
```

```python
good = {i:j for i, j in scores.items() if j >= 80}
good
#이런 식으로 딕셔너리 역시 컴프리헨션이 사용 가능하다. 
```

```python
li = [1, 2, 3, 4, 7]
[*filter(lambda x : x%2==0, li)] # [2, 4]
# [*map(lambda x : x%2==0, li)]

#데이터 손실 가능성. len확인해보자 .

li1 = [1, 2, 3, 4, 5]
li2 = [10, 20, 30, 40, 50, 60]
list(map(lambda x, y:x+y, li1, li2)) # map 등 함수형 문법을 차용한 함수를 사용할 때 주의점.
#여러 개의 집합자료형을 얹어서 사용한다면 가장 len()이 짧은 자료형을 기준으로 작동한다.###

```

```python
alist = ['사과', '바나나', '딸기', '오렌지'] # 4개
blist = ['Apple', 'Banana', 'Strawberry'] # 3개
clist = [100, 200, 300, 400, 500] # 5개
[*zip(alist, blist, clist)] #이것 역시 짧은 것.
```


```python
subjects = ['math', 'history', 'english', 'computer engineering']
scores = [90, 80, 95, 100]

{subject:score for subject, score in zip(subjects, scores)}


dict([*zip(subjects, scores)])

# {'math': 90, 'history': 80, 'english': 95, 'computer engineering': 100}
```

### Reduce 
```python
#0~10까지 모두 더한 값
list1 = list(range(0,11))
reduce(lambda x,y : x+y, list1)

reduce(lambda x,y : x+y, range(11))
##reduece
```

```python
test2 = [{'name' : 'a', 'age' : 1}, {'name' : 'b', 'age' : 2}, {'name' : 'c', 'age' : 3}]
reduce(lambda x, y: x + y['age'], test2, 0) / len(test2)

# 얘가 X가 되고, {'name' : 'a', 'age' : 1}
# 얘가 Y가 된다  {'name' : 'b', 'age' : 2)
#뎁스를 타고 들어갈 때, 초기의 결과값...이 뭔지....
```
