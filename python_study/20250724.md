SELECT title, YEAR(release_date), screens,
RANK() OVER (PARTITION BY YEAR(release_date) ORDER BY screens DESC ROWS BETWEEN unbounded preceding and unbounded following) as "rank",
MAX(screens) OVER (PARTITION BY YEAR(release_date) ORDER BY screens DESC ROWS BETWEEN unbounded preceding and unbounded following) as "max"

FROM movies 
WHERE release_date is not null AND screens is not NULL ORDER BY YEAR(release_date) desc;

이건 틀려?

### ChatGPT의 말:

**문법적으로는 실행되지만, 불필요한 부분 때문에 “틀린” 형태에 가깝습니다.**

특히 `ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING`을 `RANK()`에 붙인 게 핵심 문제예요.

---

### **왜 문제가 되나?**

1. **`RANK()`는 프레임(frame)을 사용하지 않음**
    - `RANK()`, `DENSE_RANK()`, `ROW_NUMBER()` 같은 **순위 함수**는
        
        윈도우 프레임(`ROWS BETWEEN`)을 지정해도 무시합니다.
        
    - `PARTITION BY`와 `ORDER BY`만으로 순위를 계산하므로,
        
        프레임을 붙여도 결과가 바뀌지 않고, 오히려 혼란만 줍니다.
        
2. **`MAX()`는 프레임을 지정할 필요가 없음 (이 경우)**
    - 연도별 최대 `screens`를 구할 때는, `ORDER BY`가 필요하지 않아요.
        
        단순히 파티션 전체에서 `MAX()`를 구하면 되기 때문이죠.
        
    - `ORDER BY screens DESC` + `ROWS ...`는 의미가 없고 성능만 떨어뜨립니다.

---

### **올바른 간결한 쿼리**

```sql
sql
복사편집
SELECT
    title,
    YEAR(release_date) AS release_year,
    screens,
    RANK() OVER (
        PARTITION BY YEAR(release_date)
        ORDER BY screens DESC
    ) AS rank,
    MAX(screens) OVER (
        PARTITION BY YEAR(release_date)
    ) AS max_screens
FROM movies
WHERE release_date IS NOT NULL
  AND screens IS NOT NULL
ORDER BY release_year DESC, rank;

```

---

### **결과적으로 다른 점**

- **불필요한 프레임(`ROWS BETWEEN ...`)을 제거** → 순위 함수는 원래 프레임 안 씀.
- `MAX()`도 `ORDER BY`와 프레임 없이 **파티션 전체**에서 바로 계산 → 같은 결과지만 더 효율적.

---

### **정리**

- 지금 쿼리는 **결과는 나올 수 있지만**,
    - `RANK()`는 프레임 구문이 무시되고,
    - `MAX()`는 불필요하게 `ORDER BY`를 써서 쓸데없이 무겁게 실행됩니다.
- 성능과 가독성을 위해 위처럼 단순화하는 게 맞습니다.

# 윈도우 함수들은 **인자를 꼭 필요로 하는 그룹**과 **필요 없는 그룹**으로 나눌 수수

```sql
1. 인자가 필요한 윈도우 함수들
(계산 대상 컬럼이 꼭 있어야 함)

이 그룹은 어떤 컬럼을 집계·계산할지 명시해야 하므로 반드시 인자를 넣어야 합니다.

집계/누적 계열

SUM(컬럼)

AVG(컬럼)

MIN(컬럼)

MAX(컬럼)

COUNT(컬럼)

값 추출 계열

FIRST_VALUE(컬럼)

LAST_VALUE(컬럼)

LAG(컬럼, [이전 행 수], [기본값])

LEAD(컬럼, [다음 행 수], [기본값])

이들은 무슨 컬럼을 대상으로 계산할지 지정해야 결과가 나오며,
일부 (LAG, LEAD)는 **두 번째 인자(몇 행 전/후)**와 **세 번째 인자(NULL 대신 기본값)**도 선택적으로 가집니다.

2. 인자가 필요 없는 윈도우 함수들
(그냥 호출만으로 동작)

이 그룹은 행 번호나 순위 자체를 매기는 역할이라, 계산할 대상 컬럼이 필요하지 않아요.
단, ORDER BY와 PARTITION BY는 필요할 수 있습니다.

순위/번호 계열

ROW_NUMBER()

RANK()

DENSE_RANK()

NTILE(N) ← N (몇 구간으로 나눌지)만 필요, 컬럼은 없음.

이 함수들은 컬럼을 직접 계산하지 않고,
정렬된 행 순서나 파티션 정보만으로 순위나 그룹을 매깁니다.
```

 # # 

- - 부서별로 직원들이 최대임금 대비 몇퍼센트 정도 임금을 받고 있는지
- - 부서별로 직원들이 최대임금 대비 몇퍼센트 정도 임금을 받고 있는지
USE fisa;
SELECT job, ename, sal,
first_value(sal) OVER (PARTITION BY job ORDER BY sal DESC) as "max",
CONCAT(((sal / first_value(sal) OVER (PARTITION BY job ORDER BY sal DESC))-1), "%") as "ratio"
FROM emp;

**VIEW 로 만들기**  

```sql
CREATE VIEW ratio_by_sal_with_job as SELECT job, ename, sal, 
	first_value(sal) OVER (PARTITION BY job ORDER BY sal DESC) as "max",
	CONCAT(((sal / first_value(sal) OVER (PARTITION BY job ORDER BY sal DESC))-1), "%") as "ratio"
FROM emp;

SELECT * FROM ratio_by_sal_with_job;
```

# 프로시저

```sql
-- # 여러 개으 ㅣ 쿼리문ㄴ을 절차....대로... 실행...?
-- 잠깐 마침표 대신 이걸 사용할 게  게 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
-- 82s년보다 먼저 입사한 사람의 수를 리턴하는 함수 
use fisa;
DELIMITER //
CREATE PROCEDURE employees_hireyear(out employee_count INT)
BEGIN 																									
	SELECT count(hiredate) INTO employee_count FROM fisa.emp WHERE YEAR(hiredate) <= 1982;
END //
DELIMITER ;

CALL fisa.employees_hireyear(@employee_count);
SELECT @employee_count;

-- SET @cnt = 0;

-- -- 프로시저 호출 (OUT 변수 전달)
-- CALL fisa.employees_hireyear(@cnt);

-- -- OUT 값 확인
-- SELECT @cnt AS employee_count;
-- 저장 프로시저를 호출합니다.

-- 결과를 확인합니다.

USE fisa;
DELIMITER //
CREATE PROCEDURE employees_hireyear(IN target_year INT, out employee_count INT)
BEGIN
    SELECT count(hiredate) INTO employee_count FROM fisa.emp WHERE YEAR(hiredate) <= target_year;
END //
DELIMITER ;

CALL fisa.employees_hireyear(2000, @employee_count);
SELECT @employee_count;

-- IF 문을 사용한 스토어드 프로시저: 
-- emp 테이블을 활용하여 hiredate가 1984년 이전인 직원들의 수를 세는 스토어드 프로시저 예제를 만들어보세요.
-- procedure 이름은 employees_hireyear로 지정합니다.

-- employee_count 가 10 이상이면 명예퇴직 기간이고, else "OKAY"
USE fisa;
DELIMITER //
CREATE PROCEDURE empployees_hireyear2(IN target_year INT, out employee_count INT, OUT status_message VARCHAR(10))
BEGIN
-- 계산
    SELECT count(hiredate) INTO employee_count FROM fisa.emp WHERE YEAR(hiredate) <= target_year;
--  조건삼아 sstatus 를 바꿉니다. 
	IF employee_count >= 10 THEN 
    
		SET status_message ="명퇴기간";
    ELSE 
		SET status_message = "OK";
        
	END IF;

END //
DELIMITER ;

CALL fisa.empployees_hireyear2(2000, @employee_count, @status_message);
SELECT @employee_count, @status_message;

```

# trigger

```sql
DROP TRIGGER IF EXISTS backtable_update_trg;

-- 트리거 작성
DELIMITER //

-- @msg 
CREATE TRIGGER backtable_update_trg -- 트리거 이름
	AFTER DELETE -- 트리거가 동작할 순서 작업 
	ON orders -- ON 트리거를 부탁할 테이블명
	FOR EACH ROW -- 각 행에 대해서 적용해  /// 관용
BEGIN
	INSERT INTO backup_order (order_id, customer_id, product_id, order_date, cancle_date, quantity) 
    VALUES (OLD.order_id, OLD.customer_id, OLD.product_id, OLd.order_date, NOW(), OLD.quantity);
END // 

DELIMITER ;

SELECT * FROM orders;
SELECT * FROM backup_order;

DELETE FROM orders WHERE order_id = 2; 
```
