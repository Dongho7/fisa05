# Numpy
---
```python
np.array([1,2,3])
np.array([1.2, 3,5], dtype=float)

np.arange(10,26, 5)

np.zeros((3,4))

np.ones((2,3,4))
np.empty((3,2))
```
**numpy로 정규분포 데이터 만들기!!**
```python
np.random.normal(size = 100)
```


```python
np.substract(a,b) #a-b
np.add(b,a) #a+b
np.divide(a,b) #a/b
np.multiply(a,b) #a*b

np.sqrt(b)
np.log(a)

```

```python
a == b
a<2
a[a<2]

(1<x)&(x<3) 
#와 같은 형식 가능
```

```python
a.sum()
a.min()
a.max()
b.cumsum() #누적합
a.mean()
b.median()
a.corrcoef()

#그리고!!!!!!!!!!!최빈값 같은 겨웅에는 
import statistics as st
st.mode(a) #동점이 있다면 첫 번째로 계산된 값만 리턴
```
***test2.argmax(axis=0)*** 처럼 위치를 반환하는 애는 argmax, argmin
```python
test2= np.array([[10,2,3,4], 
                 [6,7,8,2]])
 
test2.flatten() #속에서는 이렇게 관리하고 있기 때문에 다차원의 배열에서도, test2.argmax 사용 가능하다. 

#그래서, 나는 다차원을 유지하면서 argmax를 쓰고 싶다면
test2.argmax(axis=0) #0번 방이 커, 1번 방이 커.....array([0, 1, 1, 0]) # 10vs 6
test2.argmax(axis=1) #10dl 제일 커 , 8이 제일 커 

```
```python

print(test4.shape)  # (3, 2, 3)
print(test4.itemsize) #한 원소가 차지하는 방의 byte 사이즈.8바이트(1비트) 각각...
print(test4.dtype) #
print(test4.ndim) #차원
print(test4.size) #2*3*4=24
print(test4.shape)

```

test = np.array([15, '20', True, 34]) #이상한 애들 섞여 있으면 다 문자열로 받는다.
가령, object로...

# Concatenate 연습
```python
test4 = np.array([[[ 1,  4,  1],
                  [ 2,  7,  2]],

                  [[ 3,  2,  3],
                  [21,  3,  4]]])
print(test4.shape)
# shape: (2, 2, 3)

to_add = np.array([
    [[10, 20, 30]],   # 첫 번째 블록에 추가할 행
    [[40, 50, 60]]    # 두 번째 블록에 추가할 행
])  # shape = (2, 1, 3)

test4 = np.concatenate((test4, to_add), axis=1)
test4
#shape = (2, 3, 3)

```

```python
test4 = np.array([[[ 1,  4,  1],
                  [ 2,  7,  2]],

                  [[ 3,  2,  3],
                  [21,  3,  4]]])
print(test4.shape)
# shape: (2, 2, 3)

to_add = np.array([
    [[100], [200]],
    [[300], [400]]
])  # shape = (2, 2, 1)

result = np.concatenate((test4, to_add), axis=2)
print(result.shape) 
 # (2, 2, 4)

###############
a1 = np.arange(10, 19)
a1 = a1.reshape(1,3,3)

a2 = np.arange(20, 29)
a2 = a2.reshape(1,3,3)

a3 = np.arange(30, 39)
a3 = a3.reshape(1,3,3)

a12 = np.concatenate((a1,a2), axis=0)
#shape 2,3,3

a123 = np.concatenate((a12, a3), axis=0)

```



**random int만들기**

```python
np.random.randint(1,100)

##또 다른 방법
np.random.defalut_rng(3) #seed
rng.integers(low=1, high=101, size=5)

```

**choice**
```python
#복원
a = np.array([1,2,3,4,5])
np.random.choice(a, 2)

#array([5, 2])
```

**average**
```python
#a = np.array([1,2,3,4,5])
np.average(a, weights=[0.2, 0.4, 0.1, 0.1, 0.2])
np.max(a)
```


**flip**
```pytohn
x = np.array([100, 3, 20, 50, 80, 4])

%time np.sort(x)[::-1]
%time np.flip(np.sort(x))

```
**슬라이싱**
```python
x = np.array([[ 1,2,  3,  4],[ 5,  6,  7,  8],[ 9, 10, 11, 12]])

bb[1:2,1:2] #슬라이싱은 차원이 남아있다. #[[6]]
bb[1,1] #스칼라값만 남고 6


bb[:,2:4] #이런 식의 
bb[:2, :] #이런 식의 
```


**nan의 처리**
```python
x =x.astype("float")
x[-1][-1] = np.nan
x[-1][-2] = np.inf

#nan을 어떻게 처리할 건지? 
np.isnan(x)
np.isnan(x).sum() #nan의 개수를 셀 수 있다.

np.isinf(x)
np.isinf(x).sum()

np.isfinite(x)

```

