# 정규표현식
---
```python
import re

matches = re.findall(r"happy", string, re.IGNORECASE)
print(matches)
print("개수:", len(matches))

#happy를 찾을 건데, 대소문자 무시해서! 
#string.lower().find("happy) 
# 정규표현식에서는 r을 습관적으로 붙여주자. 

matches = re.findall(r"happy", string, re.I|re.M)   ##첫 시작이 ...그리고 대소문자 무시
print(matches)
print("개수:", len(matches))
```

```python
name = "신동호"
re.sub(r"([가-힣])([가-힣])([가-힣])", r"\1*\3", name)

re.sub(r"([가-힣])([가-힣]+)([가-힣])", r"\1*\3", name) #사이에 몇 글자가 들어오든지... 다 별로 ...

#re.sub는 대체인데, 위치를 소괄호로 분리해서 1부터 순서대로 끊어서 부르는 그루핑과 연계해서 많이 사용한다.
```

```python
pattern = r'^[a-zA-Z0-9._+-]+[@]+[a-zA-Z0-9-]+\.[a-zA-Z0-9.-]+$'
#한 글자 이상으로 들어가는..... ///

for email in emails:
    if re.match(pattern, email):
        print(f"올바른 형식: {email}")
    else:
        print(f"잘못된 형식: {email}")

```

#### 문자열 포멧팅 잡기술
```pythonn
a= 100000
b= 0.1234


# print(f'The sum of {a:10}+{round(b)} ={a+b}') #print 깔끔하게
# print(f'The sum of {a:.2f}+{round(b)} ={a+b}')
print(f'The sum of {a:,}+{b:.1%} ={a+b:,}')  #세 자리수마다 콤마를 찍게 만들게ㅣ.........../// % 자동완성(1자리수까지)
print(f'The sum of {a:.2e}+{b:.1%} ={a+b:,}')## 지수표기
```
---

# 모듈
# 모듈

- pip install --upgrade pip: pip를 업데이트하는 명령어. 처음 가상환경을 만들면 최신 패키지 설치를 위해 꼭 한 번 해줄 것이 권장됩니다.
    - pip install 패키지==버전: 특정 버전의 패키지를 설치(예: pip install requests==2.9.0)
    - pip install "패키지<=버전": 특정 버전 이하의 패키지를 설치(예: pip install "pandas<=1.5"
    - pip install "패키지~=버전": 특정 버전과 호환되는 가장 최신 버전을 받아서 설치(주 버전은 고정, 마이너/패치 버전만 최신으로 설치, pip install "pandas>=2.2.0,<2.3.0") 과 같음

#보통은 모듈명까지만 불러오거나 모듈ㄹ명을 가져와서 그것을 별명으로 지정해준다

- pip show 패키지명: 현재 설치된 패키지의 정보 확인(버전 등)
- pip list(사람이 보기 좋게) 또는 pip freeze(파이썬이 이해할 수 있게): 현재 환경에 설치된 패키지 목록 출력
- pip uninstall 패키지: 패키지 삭제

---
# Try Except
```pytohn

try: # try 안에 있는 코드들을 잘 지켜봐~ 
    num = input('정수를 입력하세요: ') 

    if num >= 0:
        print('True')
    else:
        print('잘못 입력했습니다.')

except (ValueError,TypeError) as e: #ㅇㅖ외를 한꺼번에 처리
    print('값 입력에 문제가 있군요.')
    print(e) # 메시지 자체를 수집할 수 있습니다. 개발자가 로그로 남겨서 향후 개선에 참고

except Exception as e: # 예외처리시 하위예외를 먼저 작성하고 상위예외를 작성합니다.
    print('뭔지모르겠지만 예외가 발생했네요.')
    print(e)

```

```python
try: # try 안에 있는 코드들을 잘 지켜봐~ 
    num = input('정수를 입력하세요: ') 

    if num >= 0:
        print('True')
    else:
        print('잘못 입력했습니다.')

except (ValueError,TypeError) as e: #ㅇㅖ외를 한꺼번에 처리
    print('값 입력에 문제가 있군요.')
    print(e) # 메시지 자체를 수집할 수 있습니다. 개발자가 로그로 남겨서 향후 개선에 참고

except Exception as e: # 예외처리시 하위예외를 먼저 작성하고 상위예외를 작성합니다.
    print('뭔지모르겠지만 예외가 발생했네요.')
    print(e)

```

#예외 처리를 함수 안에서 만드는 경우가 있고, -계속 똑같은 방식으로 사용할 때는
#함수 안에서 예외를 처리하면 실행 시 중복된 코드를 제거하는 것이 가능합니다 
```python
def safe_divide(a, b):
    try:
        return a / b
    except ZeroDivisionError:
        return "0으로 나눌 수 없습니다."

# 반복적으로 다양한 입력을 받아도 항상 같은 방식으로 처리
print(safe_divide(10, 2))  # 5.0
print(safe_divide(5, 0))   # "0으로 나눌 수 없습니다."
print(safe_divide(3, 1))   # 3.0

```

반면 함수가 실행되는 부분에 예외처리를 할 때는 , 동작 자체는 비슷한데, 계속 다른 상황에 사용된다면
```python
def divide(a, b):
    return a / b  # 예외 처리는 안 함

# 상황 1: 사용자에게 에러 메시지를 출력하고 계속 진행
try:
    print(divide(5, 0))
except ZeroDivisionError:
    print("경고: 0으로 나눌 수 없습니다. 기본값 0을 사용합니다.")
    result = 0

# 상황 2: 예외 발생 시 바로 종료시키고 로그 기록
try:
    print(divide(10, 0))
except ZeroDivisionError as e:
    print(f"[로그기록] 치명적 오류 발생: {e}")
    raise SystemExit("프로그램을 종료합니다.")
```



```python
file_name = input("파일이름을 입력하세요 : ")

try:
    f = open(file_name, 'r')
    print("파일 읽기모드 열기 성공")
except FileNotFoundError as e:
    f = open(file_name, 'w')
    f.write("안녕하세요, 파일 없어서 작성")
    print(e)
    print("파일 열기 실패 > 내용 작성")
except Exception as e:
    print("다른 예외가 존재합니다. ")
    
else:
    print('-' * 5, "파일 내용 출력", '-' * 5)
    while True:
        line = f.readline()
        if not line:
            break
        print(line)
    print('-' * 25)
finally:
    f.close()
    print("파일 닫기")
```
